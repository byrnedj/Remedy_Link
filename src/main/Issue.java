package main;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * The Issue class is a way of representing a JIRA issue or REMEDY defect. 
 * You will notice I used the JIRA naming convention of calling things issues, instead of the REMEDY Defect terminology.
 * For all practical purposes it doesn't matter, if you want to change the name back to Defect, I won't be upset.
 * 
 * The next part here does matter:
 * I used the REMEDY field naming convention. In the static initialization section you will find where I initialize the field naming maps.
 * For example, in REMEDY they use "name" the corresponding JIRA field is "summary".
 * 
 * If you want to add to the list of fields that are synced, you must update the following:
 * 1. JIRA_NAME_MAP - do another "put" where the key is the corresponding field in JIRA and the value is the field in REMEDY
 * 2. REMEDY_NAME_MAP - do another "put" where the key is the corresponding field in REMEDY and the value is the field in JIRA
 * 		- It's basically the same thing just reversed.
 * 3. mSyncedFieldList - add the field name ( REMEDY representation ) to the list.
 * 
 * Note: if the field is somewhat special, like the assignee field for JIRA or priority, then you need to check to make sure
 * that the field is being processed correctly in the Service class. 
 * - Specifically the convert methods.
 * 
 * 
 * Thanks for reading, you can get the author at:
 * @author Daniel Byrne - byrnedj12@gmail.com if he isn't in the corporate directory.
 *
 */

//TODO: Maybe switch to JIRA field naming for consistency across all links.
public class Issue
{

	private String mID;
	private String mJIRAKey;
	private Date mLastModified;
	private boolean mHasChanged;
	private boolean mAdded;
	
	//The fields we will sync are defined in mSyncedFieldList
	private Map<String, String> mSyncedFields;
	
	
	//Maps to keep fields straight
	public static Map<String, String> JIRA_NAME_MAP;
	public static Map<String, String> REMEDY_NAME_MAP;
	public static List<String> mSyncedFieldList;

	//static initializers for the maps we use to find our way
	static 
	{
		//List of the currently synced fields.
		//TODO: Update this map with remedy values
		mSyncedFieldList = new ArrayList<String>();
		mSyncedFieldList.add( "description" );
		mSyncedFieldList.add( "name" );
		mSyncedFieldList.add( "status" );
		mSyncedFieldList.add( "detected-by" );
		mSyncedFieldList.add( "owner" );
		
		//KEY = JIRA FIELD NAME
		//VALUE = REMEDY FIELD NAME
		//TODO: Update this map with remedy values
		JIRA_NAME_MAP = new HashMap<String,String>();
		JIRA_NAME_MAP.put( "reproducible", "reproducible");
		JIRA_NAME_MAP.put( "root-cause", "root-cause" );
		JIRA_NAME_MAP.put( "customfield_10609", "id");
		JIRA_NAME_MAP.put( "description", "description");
		JIRA_NAME_MAP.put( "priority", "priority" );
		JIRA_NAME_MAP.put( "dev-comments", "dev-comments" );
		JIRA_NAME_MAP.put( "summary", "name" );
		JIRA_NAME_MAP.put( "created", "creation-time" );
		JIRA_NAME_MAP.put( "updated", "last-modified" );
		JIRA_NAME_MAP.put( "customfield_10612", "status" );
		JIRA_NAME_MAP.put( "closing-date", "closing-date" );
		JIRA_NAME_MAP.put( "detected-in-rcyc", "detected-in-rcyc" );
		JIRA_NAME_MAP.put( "detected-in-rel", "detected-in-rel" );
		JIRA_NAME_MAP.put( "severity", "severity" );
		JIRA_NAME_MAP.put( "bug-ver-stamp", "bug-ver-stamp" );
		JIRA_NAME_MAP.put( "reporter", "detected-by");
		JIRA_NAME_MAP.put( "assignee", "owner");
		
		//KEY = REMEDY FIELD NAME
		//VALUE = JIRA FIELD NAME
		//TODO: Update this map
		REMEDY_NAME_MAP = new HashMap<String,String>();
		REMEDY_NAME_MAP.put( "reproducible","reproducible" );
		REMEDY_NAME_MAP.put( "root-cause" ,"root-cause" );
		REMEDY_NAME_MAP.put( "id", "customfield_10609" );
		REMEDY_NAME_MAP.put( "description","description" );
		REMEDY_NAME_MAP.put( "priority","priority");
		REMEDY_NAME_MAP.put( "dev-comments" ,"dev-comments");
		REMEDY_NAME_MAP.put( "name","summary");
		REMEDY_NAME_MAP.put( "creation-time", "created");
		REMEDY_NAME_MAP.put( "last-modified", "updated" );
		REMEDY_NAME_MAP.put( "status", "customfield_10612" );
		REMEDY_NAME_MAP.put( "closing-date", "closing date" );
		REMEDY_NAME_MAP.put( "detected-in-rcyc", "detected-in-rcyc");
		REMEDY_NAME_MAP.put( "detected-in-rel", "detected-in-rel" );
		REMEDY_NAME_MAP.put( "severity", "severity" );
		REMEDY_NAME_MAP.put( "bug-ver-stamp", "bug-ver-stamp");
		REMEDY_NAME_MAP.put( "detected-by", "reporter");
		REMEDY_NAME_MAP.put( "owner", "assignee");

	}

	/**
	 * Constructor - There are a few fields that aren't kept 'in sync' per say because the are permanent or changed automatically.
	 * mID = permanent, this is a unique id generated by HPQC, it would never be changed by JIRA
	 * mLastModified = when issues are updated via POST this time get updated.
	 * 
	 * Other fields:
	 * mAdded is used for knowing if this was a new issue added to JIRA
	 * mHasChanged is used to know if the field values were changed at all.
	 * @param aFields
	 */
	public Issue ( Map<String, String> aFields )
	{
		//Main ones that aren't being synced
		mID = aFields.get( "id" );
		mAdded = false;
		mHasChanged = false;
		
		SimpleDateFormat dateFormat = new SimpleDateFormat( "yyyy-MM-dd");
		//Last modified procedures for formatting times
		try
		{	
			if ( aFields.containsKey( "isJIRA" ) && aFields.get( "isJIRA" ).equals( "true" ) ) 
			{
				String toParse = aFields.get( "last-modified" );
				String left = toParse.substring( 0, toParse.indexOf( 'T' ) );
				String right = toParse.substring( toParse.indexOf( 'T' ) + 1, toParse.indexOf( '.' ) );
				toParse = left + " " + right;
				dateFormat = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" );
				mLastModified = dateFormat.parse( toParse  );
			}
			//TODO: Remedy date format.
			else
			{
				dateFormat = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" );
				mLastModified = dateFormat.parse( aFields.get( "last-modified" ) );
			}
		}
		catch( Exception e )
		{
			e.printStackTrace();
		}
		
		//Add the synced fields
		mSyncedFields = new HashMap<String, String>();
		for ( int i = 0; i < mSyncedFieldList.size(); i++ )
		{
			String key = mSyncedFieldList.get( i );
			String value = aFields.get( key );
			//put the key value pair into the map
			mSyncedFields.put( key, value );
		}
	}
	/**
	 * This is called on a new cycle so that we don't overlap what was added
	 */
	public void resetAdded()
	{
		mAdded = false;
	}
	/**
	 * This is called on a new cycle so that we don't overlap what was changed
	 */
	public void resetChanged()
	{
		mHasChanged = false;
	}

		
	/**
	 * Simple check for if the issue has changed
	 * @param aOldIssue to compare
	 * @return true if changed, false otherwise
	 */
	public boolean hasChanged()
	{
		return mHasChanged;
	}
	
	/**
	 * Set the issue to changed or not
	 * @param true if changed, false if not changed
	 */
	public void setChanged( boolean aChanged )
	{
		mHasChanged = aChanged;
	}
	
	/**
	 * Determines if the issue was added to the JIRA list.
	 * @return true if added, false otherwise
	 */
	public boolean wasAdded()
	{
		return mAdded;
	}
	
	/**
	 * Sets the added field, if the issue was added to the JIRA list
	 * @param true if added, false otherwise
	 */
	public void setAdded( boolean aAdded )
	{
		mAdded = aAdded;
	}
	
	/**
	 * Get last modified time of the issue
	 * @return the modified time and date
	 */
	public Date getLastModified()
	{
		return mLastModified;
	}

	/**
	 * Return the Id of the issue
	 * @return issue id
	 */
	public String getID()
	{
		return mID;
	}
	
	/**
	 * Sets the JIRA Issue key
	 * @param key, the JIRA Issue key
	 */
	public void setJIRAKey( String key )
	{
		mJIRAKey = key;
	}
	
	/**
	 * Returns the JIRA Issue key
	 * @return the JIRA Issue key
	 */
	public String getJIRAKey()
	{
		return mJIRAKey;
	}
	
	/**
	 * This is the map of the currently sync fields. Update mSyncedFields  and mSyncedFieldList for more fields
	 * @return a map of the fields being sync
	 */
	public Map<String, String> getSyncedFields()
	{
		return mSyncedFields;
	}
	
	public void setSyncedFields( Map<String, String> aNewValues )
	{
		for ( int i = 0; i < mSyncedFieldList.size(); i++ )
		{
			String fieldName = mSyncedFieldList.get( i );
			String currentFieldValue = mSyncedFields.get( fieldName );
			String newFieldValue = aNewValues.get( fieldName );
			
			//Null checks as we want to use blank values instead
			if ( currentFieldValue == null )
			{
				currentFieldValue = "";

			}
			if ( newFieldValue == null )
			{
				 newFieldValue = "";

			}
			
			//Set the new field value
			if ( !currentFieldValue.equals( newFieldValue ) )
			{
				System.out.println( "Changing issue " + this.getID() + ", " + fieldName + "'s value to: " + newFieldValue +
									", from: " + currentFieldValue );
				mSyncedFields.put( fieldName, newFieldValue );
				mHasChanged = true;
			}
		}


	}
}
